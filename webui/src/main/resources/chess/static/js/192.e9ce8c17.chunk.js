(()=>{"use strict";function e(e,t,o,i){return{x:e,y:t,z:void 0!==o?o:void 0,boardId:i||void 0}}function t(e,t,o){return{x:e,y:t,boardId:o}}function o(e){return c(e)?e.x:Math.sqrt(3)/2*e.q}function i(e){return c(e)?e.y:3/4*e.r}function r(e){return l(e)?p(e).q:2/Math.sqrt(3)*e.x}function s(e){return l(e)?p(e).r:4/3*e.y}function n(e,t){if(c(e))return{...e,x:t};{const o=2/Math.sqrt(3)*t;return{...e,q:o,s:-o-e.r}}}function a(e,t){if(c(e))return{...e,y:t};{const o=4/3*t;return{...e,r:o,s:-e.q-o}}}function c(e){return"x"in e&&"y"in e}function l(e){return"q"in e&&"r"in e&&"s"in e}const h=["1","2","3","4","5","6","7","8"],u=["a","b","c","d","e","f","g","h"];function d(t){if("string"===typeof t){const[o,i]=t.split("");return e(u.indexOf(o),h.indexOf(i),void 0,"0")}if(Array.isArray(t))return t.length>=3?{q:t[0],r:t[1],s:t[2],boardId:void 0}:e(t[0],t[1]);if("object"===typeof(o=t)&&(c(o)||l(o)))return t;var o;throw new Error("Invalid position format")}function v(e,t){if(c(e)&&c(t)){var r,s;const n=o(e),a=i(e),c=o(t),l=i(t);if(n!==c||a!==l)return!1;if(null!=e.boardId&&null!=t.boardId&&e.boardId!=t.boardId)return!1;return(null!==(r=e.z)&&void 0!==r?r:0)===(null!==(s=t.z)&&void 0!==s?s:0)}if(l(e)&&l(t)){const o=p(e),i=p(t);return o.q==i.q&&o.r==i.r&&o.s==i.s&&(null==e.boardId||null==t.boardId||e.boardId==t.boardId)}return!1}function g(e){return c(e)?`${e.boardId?e.boardId+":":""}${u[e.x]}${h[e.y]}`:`${e.boardId?e.boardId+":":""}${e.q},${e.r}`}function p(e){if(l(e)){let{q:t,r:o,s:i}=e;return t+o+i!==0&&(i=-t-o),{q:t,r:o,s:i}}return e}class f{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];this.initialState=void 0,this.undoneMoves=[],this.className="MoveHistory",this.isInitializing=!1,this.moves=[],this.moves=[...t],this.initialState=[...e]}resetWithNewState(e){console.debug(`${this.className}: Resetting move history with new initial state`),this.initialState=[...e],this.clear()}addMove(e){if(this.isInitializing)return this;return this.moves.some((t=>v(t.from,e.from)&&v(t.to,e.to)))||(this.moves.push(e),this.undoneMoves=[],this.isInitializing=!1),this}getLastMove(){return this.moves.length>0?this.moves[this.moves.length-1]:null}clear(){this.moves=[],this.undoneMoves=[]}undoLastMove(){if(this.canUndo()){const e=this.moves.pop();return this.undoneMoves.push(e),{move:e,boardState:null}}return{move:null,boardState:null}}redoMove(){if(this.canRedo()){const e=this.undoneMoves.pop();return this.moves.push(e),e}return null}canRedo(){return this.undoneMoves.length>0}canUndo(){return this.moves.length>0}clone(){const e=new f(this.initialState,this.moves);return e.undoneMoves=[...this.undoneMoves],e.isInitializing=this.isInitializing,e}getUndoneMovesCount(){return this.undoneMoves.length}getMovesCount(){return this.moves.length}toString(){return this.moves.map((e=>`${g(e.from)}-${g(e.to)}`)).join(", ")}}class m{constructor(){this.pieceValues=new Map,this.verbosityLevel=0,this.gameModel=void 0,this.config=void 0,this.aborted=!1,this.evaluationWeights={kingSafety:200,material:100,pieceActivity:10,mobility:10,pawnStructure:20,center:15,development:15,pieceSafety:150},this.pieceValues=new Map([["pawn",100],["knight",320],["bishop",330],["rook",500],["queen",900],["king",2e4]])}cloneGameState(e){var t,o;return{...e,board:e.board?[...e.board.map((e=>({...e})))]:[],capturedPieces:{white:null!==(t=e.capturedPieces)&&void 0!==t&&t.white?[...e.capturedPieces.white]:[],black:null!==(o=e.capturedPieces)&&void 0!==o&&o.black?[...e.capturedPieces.black]:[]},moveHistory:e.moveHistory?e.moveHistory.clone():new f}}initialize(e,t){this.gameModel=e,t&&(this.config={...this.config,...t},void 0!==t.verbosityLevel&&(this.verbosityLevel=t.verbosityLevel),t.evaluationWeights&&(this.evaluationWeights={...this.evaluationWeights,...t.evaluationWeights})),this.verbosityLevel>=1&&(console.log(`Initializing BasicAIPlayer with verbosity level ${this.verbosityLevel}`),this.verbosityLevel>=2&&(console.log(`Configuration: ${JSON.stringify(this.config,null,2)}`),console.log(`Evaluation weights: ${JSON.stringify(this.evaluationWeights,null,2)}`)))}async calculateBestMove(e){if(!e||!e.currentTurn)return console.error("Invalid game state received in calculateBestMove"),Promise.resolve(null);const t=this.config.depthLimit||3;this.verbosityLevel>=1&&console.log(`Starting AI calculation with depth: ${t}`);let o=[];const i=this.getLegalMoves(e);if(0===i.length)return console.error("No legal moves found in calculateBestMove"),null;const r=Date.now();o=i.map((t=>({move:t,score:this.evaluatePosition(this.gameModel.makeMove(e,t),e.currentTurn)}))),this.verbosityLevel>=1&&console.log(`Total Legal Moves: ${i.length}`);this.config.timeLimit;if(o=i.map((t=>({move:t,score:this.evaluatePosition(this.gameModel.makeMove(e,t),e.currentTurn)}))),o.sort(((e,t)=>t.score-e.score)),this.verbosityLevel>=1){const e=Date.now()-r;console.log(`Evaluation completed in ${e}ms`);const t=Math.min(3,o.length);console.log(`Top ${t} moves:`);for(let i=0;i<t;i++){const e=o[i];console.log(`  ${i+1}. ${e.move.piece.color} ${e.move.piece.type} from ${g(e.move.from)} to ${g(e.move.to)}, Score: ${e.score.toFixed(2)}`)}}if(this.verbosityLevel>=1&&console.log("Time limit reached."),0===o.length)return null;const s=this.selectMoveWithRandomness(o);return this.verbosityLevel>=1&&s&&console.log(`Selected move: ${s.piece.color} ${s.piece.type} from ${g(s.from)} to ${g(s.to)}`),Promise.resolve(s)}abortCalculation(){this.aborted=!0,this.verbosityLevel>=0&&console.error("AI calculation aborted")}evaluatePosition(e,t){const o=[{value:this.evaluateKingSafety(e,t),weight:this.evaluationWeights.kingSafety},{value:this.evaluateMaterial(e,t),weight:this.evaluationWeights.material},{value:this.evaluatePieceActivity(e,t),weight:this.evaluationWeights.pieceActivity},{value:this.evaluateMobility(e,t),weight:this.evaluationWeights.mobility},{value:this.evaluatePawnStructure(e,t),weight:this.evaluationWeights.pawnStructure},{value:this.evaluateCenter(e,t),weight:this.evaluationWeights.center},{value:this.evaluateDevelopment(e,t),weight:this.evaluationWeights.development},{value:this.evaluatePieceSafety(e,t),weight:this.evaluationWeights.pieceSafety}],i=o.reduce(((e,t)=>e+t.value*t.weight),0);return this.verbosityLevel>=3&&(console.group("Position Evaluation"),o.forEach((e=>{console.log(`${Object.keys(this.evaluationWeights).find((t=>this.evaluationWeights[t]===e.weight))}: ${e.value.toFixed(2)} \xd7 ${e.weight} = ${(e.value*e.weight).toFixed(2)}`)})),console.log(`Total score: ${i.toFixed(2)}`),console.groupEnd()),i}evaluatePawnStructure(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn,o=0;const i=e.board.filter((e=>"pawn"===e.type&&e.color===t));o-=this.evaluateDoubledPieces(i),o-=this.evaluateIsolatedPieces(i);const r=e.board.filter((e=>"pawn"===e.type&&e.color!==t));return o+=this.evaluateAdvancedPieces(i,r),this.verbosityLevel>=3&&console.log(`Evaluated pawn structure for ${t}: ${o}`),o}getLegalMoves(e){this.verbosityLevel>=3&&(console.group("getLegalMoves"),console.log(`Current turn: ${e.currentTurn}`));try{const t=e.board.filter((t=>t.color===e.currentTurn)).flatMap((t=>{const o=this.gameModel.calculatePossibleMoves(e,t);return this.verbosityLevel>=3&&console.log(`Possible moves for ${t.color} ${t.type} at ${g(t.position)}:`,o.map(g)),o.map((e=>({from:t.position,to:e,piece:t})))}));return this.verbosityLevel>=3&&console.log(`Total legal moves found: ${t.length}`),t}finally{this.verbosityLevel>=3&&console.groupEnd()}}evaluateKingSafety(e){var t;let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn,s=0;const n=null===(t=e.board)||void 0===t?void 0:t.find((e=>"king"==e.type&&e.color==r));if(!n||!e.board)return this.verbosityLevel>=1&&console.warn(`No ${r} king found on the board. Returning default score.`),0;this.gameModel.isInCheck(e,r);return s+=10*e.board.filter((e=>e.color==r&&Math.abs(o(e.position)-o(n.position))<=1&&Math.abs(i(e.position)-i(n.position))<=1)).length,this.verbosityLevel>=3&&console.log(`King safety for ${r}: ${s}`),s}calculateMobilityScore(e,t){let o=this.getLegalMoves(t).filter((t=>t.piece.color==e)).length;return this.verbosityLevel>=3&&console.log(`Mobility score for ${e}: ${o}`),o}evaluatePieceSafety(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn,o=0;for(const i of e.board){const r=this.gameModel.getAttackersOfSquare(e,i.position,"white"===i.color?"black":"white"),s=this.gameModel.getAttackersOfSquare(e,i.position,i.color);if(r&&r.length>0){const e=this.pieceValues.get(i.type)||0,n=Math.min(...r.map((e=>this.pieceValues.get(e.type)||0))),a=e*r.length/((((null===s||void 0===s?void 0:s.length)||0)+1)*Math.max(n,1));o+=i.color===t?-a:a}}return o}logMove(e,t,o){this.verbosityLevel>=2&&console.log(`Move: ${e.piece.color} ${e.piece.type} from ${g(e.from)} to ${g(e.to)}, Score: ${t}, Depth: ${o}`)}negamax(e,t){if(!t||!t.currentTurn)return console.error("Invalid game state received in negamax"),0;t.currentTurn;const o=this.verbosityLevel,i=this.gameModel,r=this;return function e(t,s,n,a){const c=a.currentTurn;o>=2&&console.group(`Negamax: depth=${t}, alpha=${s}, beta=${n}`);try{if(t<=0){let e=r.evaluatePosition(a,c);return o>=2&&console.log(`Leaf node reached: depth=${t}, score=${e}`),e}if(i.isInCheckmate(a,c))return o>=2&&console.log(`Checkmate found at depth ${t}`),-2e4+t;if(i.isStalemate(a))return o>=2&&console.log(`Stalemate found at depth ${t}`),0;const l=r.getLegalMoves(a);if(0===l.length)return o>=2&&console.log(`No legal moves found at depth ${t}`),i.isInCheck(a,c)?-2e4+t:0;o>=2&&console.log(`Legal moves at depth ${t}: ${l.length}`);let h=-1/0;for(const c of l){o>=2&&console.group(`Evaluating move: ${c.piece.color} ${c.piece.type} from ${g(c.from)} to ${g(c.to)}`);try{const l=-e(t-1,-n,-s,i.makeMove(a,c));if(r.logMove(c,l,t),l>h&&(o>=2&&console.log(`New best move found: ${c.piece.type} from ${g(c.from)} to ${g(c.to)}, score: ${l}`),h=l),l>s&&(o>=2&&console.log(`New alpha: ${c.piece.type} from ${g(c.from)} to ${g(c.to)}, score: ${l}`),s=l),s>=n){o>=2&&console.log(`New best move found: ${c.piece.type} from ${g(c.from)} to ${g(c.to)}, score: ${l}`),o>=2&&console.log(`Beta cutoff at depth ${t}`);break}}finally{o>=2&&console.groupEnd(),o>=2&&console.log(`Move: ${c.piece.color} ${c.piece.type} from ${g(c.from)} to ${g(c.to)}, Score: ${h}, Alpha: ${s}, Beta: ${n}`)}}return o>=2&&console.log(`Negamax result: ${h}`),h}finally{o>=2&&console.groupEnd()}}(e||3,-1/0,1/0,t)}evaluateCenter(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn;const o=[a(n({},3),3),a(n({},3),4),a(n({},4),3),a(n({},4),4)];let i=0;for(const r of o){const o=this.gameModel.getPieceAt(e,r);o&&(i+=o.color===t?10:-10),i+=this.gameModel.isUnderAttack(e,r,t)?5:-5}return i}evaluateDevelopment(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn,o=0;const r="white"===t?0:7;for(const s of e.board.filter((e=>e.color===t)))"pawn"!==s.type&&"king"!==s.type&&i(s.position)!==r&&(o+=10);return o}selectMoveWithRandomness(e){e=e.filter((e=>{if("pawn"===e.move.piece.type){const t=Math.abs(s(e.move.to)-s(e.move.from));return!(t>2||t<1)&&(r(e.move.to)===r(e.move.from)&&(!e.move.piece.hasMoved&&t<=2||!(!e.move.piece.hasMoved||1!==t)))}if("king"===e.move.piece.type){return Math.abs(s(e.move.to)-s(e.move.from))<=1}return!0})),this.verbosityLevel>=1&&console.log(`${e.length} valid moves after filtering`);let t=this.config.randomnessFactor||.1;if(this.verbosityLevel>=2&&(e.forEach((e=>console.log(`Move: ${JSON.stringify(e.move)}, Score: ${e.score}`))),console.log(`Selecting move with randomness factor: ${t}`)),e.sort(((e,t)=>t.score-e.score)),0===e.length)return this.verbosityLevel>=0&&console.error("No valid moves available"),null;const o=e.reduce(((e,o)=>e+Math.exp(o.score*t)),0),i=Math.random()*o;this.verbosityLevel>=2&&console.log(`Total weight: ${o.toFixed(2)}, Random value: ${i.toFixed(2)}`);let n=0;for(let r=0;r<e.length;r++){const o=e[r];if(n+=Math.exp(o.score*t),i<=n)return this.verbosityLevel>=1&&console.log(`Selected move ${r+1}/${e.length} with probability weighting`),e[r].move;this.verbosityLevel>=3&&console.log(`Move ${r}: ${JSON.stringify(e[r].move)}, Score: ${e[r].score}, Weight: ${o.score}`)}return this.verbosityLevel>=1&&console.log("Defaulting to best move (first in sorted list)"),e[0].move}evaluateMaterial(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn,o=0;for(const i of e.board){const e=this.pieceValues.get(i.type)||0;o+=i.color==t?e:-e}return o}evaluatePieceActivity(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn,o=0;for(const i of e.board){const r=this.gameModel.calculatePossibleMoves(e,i)||[];r&&(o+=r.length*(i.color===t?1:-1),r||this.verbosityLevel>=1&&console.error(`No moves found for piece: ${JSON.stringify(i)}`))}return this.verbosityLevel>=3&&console.log(`Piece activity evaluation: ${o}`),o}evaluateMobility(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn;const o=this.calculateMobilityScore("white",e),i=this.calculateMobilityScore("black",e);return"white"===t?o-i:i-o}evaluateDoubledPieces(e){return 10*-e.filter(((t,i)=>e.some(((e,r)=>i!==r&&v(t.position,e.position)&&o(t.position)===o(e.position))))).length}evaluateIsolatedPieces(e){return-(15*e.filter((t=>!e.some((e=>t!==e&&1===Math.abs(o(t.position)-o(e.position)))))).length)}evaluateAdvancedPieces(e,t){return 20*e.filter((e=>!t.some((t=>Math.abs(o(t.position)-o(e.position))<=1&&("white"==e.color&&i(t.position)>i(e.position)||"black"==e.color&&i(t.position)<i(e.position)))))).length}}class b{constructor(){this.type="standard",this.width=8,this.height=8,this.depth=1,this.worldCenter=void 0,this.worldCenter={x:this.width/2-.5,y:0,z:this.height/2-.5}}getBoardSize(e){return this.width}getBoardPosition(e,t){return[0,0,0]}isValidPosition(e){const{x:t,y:o,z:i}=e;return t>=0&&t<this.width&&o>=0&&o<this.height&&(void 0===i||i>=0&&i<this.depth)}getAllPositions(){const e=[];for(let t=0;t<this.width;t++)for(let o=0;o<this.height;o++)e.push({x:t,y:o});return e}isWithinBoardBounds(e){return this.isValidPosition(e)}getAdjacentPositions(e){const t=e,o=[];for(let i=-1;i<=1;i++)for(let e=-1;e<=1;e++)0===i&&0===e||o.push({x:t.x+i,y:t.y+e});return o.filter((e=>this.isValidPosition(e)))}worldPosition(e){var t;const o=e;return{x:-(o.x-this.worldCenter.x),y:null!==(t=o.z)&&void 0!==t?t:0,z:o.y-this.worldCenter.z}}}class y{constructor(){this.geometry=void 0,this.geometry=new b}makeMove(e,t){let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];e.capturedPieces||(e.capturedPieces={white:[],black:[]});const i=e.board.find((e=>v(e.position,t.from)&&e.type===t.piece.type&&e.color===t.piece.color));if(!i)return console.warn(`No ${t.piece.color} ${t.piece.type} found at position: ${g(t.from)}`),e;const r=this.getPieceAt(e,t.to);let s=null;if("pawn"===i.type&&!r&&t.from.x!==t.to.x){const o=t.from.y,i=t.to.x;s=this.getPieceAt(e,{x:i,y:o,boardId:"0"})}if(r&&"king"===r.type)return console.error(`Attempted to capture a king at position: ${g(t.to)}. Move rejected.`),e;const n={...e,board:e.board.filter((e=>e.id!==i.id)),currentTurn:"white"===e.currentTurn?"black":"white",moveHistory:new f(e.moveHistory.initialState,e.moveHistory.moves).addMove(t),capturedPieces:{white:[...e.capturedPieces.white],black:[...e.capturedPieces.black]}};if(r&&(n.capturedPieces[r.color].push(r),n.board=n.board.filter((e=>e.id!==r.id)),t.capturedPiece=r),s&&(n.capturedPieces[s.color].push(s),n.board=n.board.filter((e=>{var t;return e.id!==(null===(t=s)||void 0===t?void 0:t.id)})),t.capturedPiece=s),"pawn"!==i.type||0!==t.to.y&&7!==t.to.y)n.board.push({...i,position:t.to,hasMoved:!0});else{const e=t.promotionType||"queen";n.board.push({...i,position:t.to,hasMoved:!0,type:e})}if("king"===i.type&&2===Math.abs(t.to.x-t.from.x)){const o=t.to.x>t.from.x,i=o?7:0,r=o?t.to.x-1:t.to.x+1,s=this.getPieceAt(e,{x:i,y:t.from.y,boardId:"0"});s&&(n.board=n.board.filter((e=>e.id!==s.id)),n.board.push({...s,position:{x:r,y:t.from.y,boardId:"0"},hasMoved:!0}))}return o||(n.gameOver=this.isGameOver(n)),n}getAttackersOfSquare(e,t,o){const i=d(t);return e.board.filter((t=>{if(t.color!==o)return!1;if("pawn"===t.type){const{x:e,y:o}=t.position,r="white"===t.color?1:-1;return[-1,1].some((t=>v({x:e+t,y:o+r,boardId:"0"},i)))}return this.calculatePossibleMoves(e,t).some((e=>v(e,i)))}))}validateMove(e,t){const o=[],i=this.getPieceAt(e,t.from);return i?(i.color!==e.currentTurn&&o.push(`It's not ${i.color}'s turn`),this.isWithinBoardBounds(t.to)||o.push("Destination position is outside the board bounds"),this.getLegalMovesForPiece(e,i).some((e=>v(e,t.to)))||o.push("The move is not in the list of legal moves for this piece"),o):(o.push(`No piece found at position: ${JSON.stringify(t.from)}`),o)}isLegalMove(e,t){return 0===this.validateMove(e,t).length}isThreefoldRepetition(e){const t=e.moveHistory.moves.map((t=>this.getBoardStateString(e))).reduce(((e,t)=>(e[t]=(e[t]||0)+1,e)),{});return Object.values(t).some((e=>e>=3))}getWinner(e){const t=e.board.find((e=>"king"===e.type&&"white"===e.color)),o=e.board.find((e=>"king"===e.type&&"black"===e.color));return t?o?this.isInCheckmate(e,"white")?"black":this.isInCheckmate(e,"black")?"white":this.isStalemate(e)?"draw":null:"white":"black"}getInitialState(){const e=this.getInitialBoardState();return{board:e,currentTurn:"white",moveHistory:new f(e),capturedPieces:{white:[],black:[]},gameMode:"head-to-head",gameOver:!1,enPassantTarget:null}}calculatePossibleMoves(e,t){const o=[],{x:i,y:r}=t.position,s="white"===t.color?1:-1;switch(t.type){case"pawn":if("white"===t.color&&4===r||"black"===t.color&&3===r){var n;let t=(null===(n=e.moveHistory)||void 0===n?void 0:n.moves)||[];const a=t.length>0?t[t.length-1]:null;a&&"pawn"===a.piece.type&&2===Math.abs(a.from.y-a.to.y)&&1===Math.abs(a.to.x-i)&&a.to.y===r&&o.push({x:a.to.x,y:r+s,boardId:"0"})}const a={x:i,y:r+s,boardId:"0"};if(this.isWithinBoardBounds(a)&&!this.getPieceAt(e,a)){o.push({x:i,y:r+s,boardId:"0"});const n=r+2*s;("white"===t.color&&1===r||"black"===t.color&&6===r)&&this.isWithinBoardBounds({x:i,y:n,boardId:"0"})&&!this.getPieceAt(e,{x:i,y:n,boardId:"0"})&&o.push({x:i,y:n,boardId:"0"})}[-1,1].forEach((n=>{const a={x:i+n,y:r+s,boardId:"0"};if(this.isWithinBoardBounds(a)){const i=this.getPieceAt(e,a);i&&i.color!==t.color&&o.push(a)}}));break;case"rook":o.push(...this.getStraightMoves(e,t));break;case"knight":[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach((e=>{let[t,s]=e;o.push({x:i+t,y:r+s,boardId:"0"})}));break;case"bishop":o.push(...this.getDiagonalMoves(e,t));break;case"queen":o.push(...this.getStraightMoves(e,t),...this.getDiagonalMoves(e,t));break;case"king":for(let s=-1;s<=1;s++)for(let n=-1;n<=1;n++)if(0!==s||0!==n){const a={x:i+s,y:r+n,boardId:"0"};if(this.isWithinBoardBounds(a)){const i=this.getPieceAt(e,a);i?i.color!==t.color&&o.push(a):o.push(a)}}if(!t.hasMoved&&null!==t.color&&!this.isInCheck(e,t.color)){const i="white"===t.color?"black":"white",s={x:7,y:r,boardId:"0"},n={x:0,y:r,boardId:"0"},a=this.getPieceAt(e,s),c=this.getPieceAt(e,n);if(a&&"rook"===a.type&&!a.hasMoved&&a.color===t.color){const t={x:5,y:r,boardId:"0"},s={x:6,y:r,boardId:"0"};this.getPieceAt(e,t)||this.getPieceAt(e,s)||this.isPositionUnderAttack(e,t,i)||this.isPositionUnderAttack(e,s,i)||o.push(s)}if(c&&"rook"===c.type&&!c.hasMoved&&c.color===t.color){const t={x:1,y:r,boardId:"0"},s={x:2,y:r,boardId:"0"},n={x:3,y:r,boardId:"0"};this.getPieceAt(e,t)||this.getPieceAt(e,s)||this.getPieceAt(e,n)||this.isPositionUnderAttack(e,n,i)||this.isPositionUnderAttack(e,s,i)||o.push(s)}}}return o.filter((o=>(!this.getPieceAt(e,o)||this.getPieceAt(e,o).color!==t.color)&&this.isWithinBoardBounds(o)))}isGameOver(e){return null!==this.getWinner(e)}isInCheck(e,t){const o=e.board,i=o.find((e=>"king"===e.type&&e.color===t));if(!i)return console.warn(`No ${t} king found on the board`),!0;const r="white"===t?"black":"white";return o.filter((t=>t.color===r&&this.getRawAttackMoves(e,t).some((e=>v(e,i.position))))).length>0}isUnderAttack(e,t,o){return this.isPositionUnderAttack({board:e.board,currentTurn:o},d(t),o)}isInCheckmate(e,t){if(!e.board.find((e=>"king"===e.type&&e.color===t)))return console.warn(`No ${t} king found on the board`),!0;if(!this.isInCheck(e,t))return!1;for(const o of this.getPiecesByColor(e,t))if(this.getLegalMovesForPiece(e,o).length>0)return!1;return!0}isStalemate(e){if(this.isInCheck(e,e.currentTurn))return!1;for(const t of this.getPiecesByColor(e,e.currentTurn))if(this.getLegalMovesForPiece(e,t).length>0)return!1;return!0}getPiecesByColor(e,t){return e.board.filter((e=>e.color===t))}getLegalMovesForPiece(e,t){const o=this.calculatePossibleMoves(e,t),i=[];for(const s of o)try{const o={...e,board:e.board.map((e=>v(e.position,t.position)?{...e,position:s}:v(e.position,s)&&e.color!==t.color?null:e)).filter(Boolean)};this.isInCheck(o,t.color)||i.push(s)}catch(r){const e=r instanceof Error?r.message:JSON.stringify(r);console.error("Error while simulating move",s,e)}return i}getPieceAt(e,t){const o=d(t);return e.board.find((e=>v(e.position,o)))||null}isWithinBoardBounds(e){return this.geometry.isWithinBoardBounds(e)}isPositionUnderAttack(e,t,o){return e.board.some((i=>i.color===o&&this.calculatePossibleMoves(e,i).some((e=>v(e,t)))))}getRawAttackMoves(e,t){if("pawn"===t.type){const{x:e,y:o}=t.position,i="white"===t.color?1:-1;return[-1,1].map((t=>({x:e+t,y:o+i,boardId:"0"}))).filter((e=>this.isWithinBoardBounds(e)))}switch(t.type){case"rook":return this.getStraightMoves(e,t);case"knight":{const{x:e,y:o}=t.position;return[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].map((t=>{let[i,r]=t;return{x:e+i,y:o+r,boardId:"0"}}))}case"bishop":return this.getDiagonalMoves(e,t);case"queen":return[...this.getStraightMoves(e,t),...this.getDiagonalMoves(e,t)];case"king":{const{x:e,y:o}=t.position,i=[];for(let t=-1;t<=1;t++)for(let r=-1;r<=1;r++)0===t&&0===r||i.push({x:e+t,y:o+r,boardId:"0"});return i}default:return[]}}isInsufficientMaterial(e){const t=e.board;if(t.length>4)return!1;if(t.every((e=>"king"===e.type)))return!0;if(3===t.length)return t.some((e=>"bishop"===e.type||"knight"===e.type));if(4===t.length){const e=t.filter((e=>"bishop"===e.type)),o=t.filter((e=>"knight"===e.type));if(2===e.length){return(e[0].position.x+e[0].position.y)%2===(e[1].position.x+e[1].position.y)%2}if(2===o.length)return!0}return!1}undoMove(e){const t=e.moveHistory.moves[e.moveHistory.moves.length-1];if(!t)return e;let o=new f(e.moveHistory.initialState,e.moveHistory.moves.slice(0,-1));o.undoneMoves=[t,...e.moveHistory.undoneMoves];const i={...e,board:e.board.filter((e=>e.id!==t.piece.id)),currentTurn:"white"===e.currentTurn?"black":"white",moveHistory:o};return i.board.push({...t.piece,position:t.from,hasMoved:!t.isFirstMove&&t.piece.hasMoved}),t.capturedPiece&&(i.board.push({...t.capturedPiece,position:t.to,hasMoved:!0}),i.capturedPieces[t.capturedPiece.color].pop()),t.enPassantCapturedPiece&&(i.board.push({...t.enPassantCapturedPiece,position:t.enPassantCapturedPiece.position,hasMoved:!0}),i.capturedPieces[t.enPassantCapturedPiece.color].pop()),i}redoMove(e){const t=e.moveHistory.undoneMoves[0];if(!t)return e;let o=new f(e.moveHistory.initialState,[...e.moveHistory.moves,t]);o.undoneMoves=e.moveHistory.undoneMoves.slice(1);const i={...e,board:e.board.filter((e=>!v(e.position,t.from))),currentTurn:"white"===e.currentTurn?"black":"white",moveHistory:o};return i.board.push({...t.piece,position:t.to,hasMoved:!0}),t.capturedPiece&&(i.board=i.board.filter((e=>e.id!==t.capturedPiece.id)),i.capturedPieces[t.capturedPiece.color].push(t.capturedPiece)),i}importState(e){const t=JSON.parse(e);if(!t.board||!Array.isArray(t.board))throw new Error("Invalid state: board is missing or not an array");if(!t.currentTurn||"white"!==t.currentTurn&&"black"!==t.currentTurn)throw new Error("Invalid state: currentTurn is missing or invalid");if(t.moveHistory?t.moveHistory instanceof f||(t.moveHistory=new f(t.board,t.moveHistory._moves||[])):t.moveHistory=new f([]),!t.capturedPieces||"object"!==typeof t.capturedPieces)throw new Error("Invalid state: capturedPieces is missing or not an array");return t}exportState(e){return JSON.stringify(e)}getBoardStateString(e){return e.board.map((e=>`${e.type}${e.color}${g(e.position)}`)).sort().join("")}getInitialBoardState(){const e=[],o=(o,i,r,s)=>{const n=`${i.charAt(0)}${o.charAt(0)}${r}${s}`;e.push({type:o,color:i,position:t(r,s,"0"),id:n,hasMoved:!1})};o("rook","white",0,0),o("knight","white",1,0),o("bishop","white",2,0),o("queen","white",3,0),o("king","white",4,0),o("bishop","white",5,0),o("knight","white",6,0),o("rook","white",7,0);for(let t=0;t<8;t++)o("pawn","white",t,1);o("rook","black",0,7),o("knight","black",1,7),o("bishop","black",2,7),o("queen","black",3,7),o("king","black",4,7),o("bishop","black",5,7),o("knight","black",6,7),o("rook","black",7,7);for(let t=0;t<8;t++)o("pawn","black",t,6);return e}getStraightMoves(e,t){return this.getMovesInDirections(e,t,[[1,0],[-1,0],[0,1],[0,-1]])}getDiagonalMoves(e,t){return this.getMovesInDirections(e,t,[[1,1],[1,-1],[-1,1],[-1,-1]])}getMovesInDirections(e,t,o){const i=[],{x:r,y:s}=t.position;for(const[n,a]of o)for(let o=1;o<8;o++){const c={x:r+o*n,y:s+o*a,boardId:"0"};if(!this.isWithinBoardBounds(c))break;const l=this.getPieceAt(e,c);if(l){l.color!==t.color&&i.push(c);break}i.push(c)}return i}}const w={randomUUID:"undefined"!==typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};var k,M=new Uint8Array(16);function P(){if(!k&&!(k="undefined"!==typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return k(M)}for(var I=[],$=0;$<256;++$)I.push(($+256).toString(16).slice(1));function A(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return(I[e[t+0]]+I[e[t+1]]+I[e[t+2]]+I[e[t+3]]+"-"+I[e[t+4]]+I[e[t+5]]+"-"+I[e[t+6]]+I[e[t+7]]+"-"+I[e[t+8]]+I[e[t+9]]+"-"+I[e[t+10]]+I[e[t+11]]+I[e[t+12]]+I[e[t+13]]+I[e[t+14]]+I[e[t+15]]).toLowerCase()}const x=function(e,t,o){if(w.randomUUID&&!t&&!e)return w.randomUUID();var i=(e=e||{}).random||(e.rng||P)();if(i[6]=15&i[6]|64,i[8]=63&i[8]|128,t){o=o||0;for(var r=0;r<16;++r)t[o+r]=i[r];return t}return A(i)};class q{constructor(e){this.type="hex",this.radius=void 0,this.width=void 0,this.height=void 0,this.depth=void 0,this.minQ=void 0,this.maxQ=void 0,this.minR=void 0,this.maxR=void 0,this.minS=void 0,this.maxS=void 0,this.HEX_WIDTH=2/Math.sqrt(3),this.HEX_HEIGHT=1,this.worldCenter=void 0,this.radius=e,this.width=2*e+1,this.height=2*e+1,this.depth=1,this.minQ=-e,this.maxQ=e,this.minR=-e,this.maxR=e,this.minS=-e,this.maxS=e;const t=this.getAllPositions();let o=1/0,i=-1/0,r=1/0,s=-1/0;t.forEach((e=>{if(!l(e))return;const t=e.q*this.HEX_WIDTH*.75,n=e.r*this.HEX_HEIGHT+e.q*this.HEX_HEIGHT/2;o=Math.min(o,t),i=Math.max(i,t),r=Math.min(r,n),s=Math.max(s,n)})),this.worldCenter={x:(o+i)/2,z:(r+s)/2}}getBoardSize(e){return 3*this.radius*(this.radius+1)+1}getBoardPosition(e,t){return[0,0,0]}getAllPositions(){const e=[];for(let t=this.minQ;t<=this.maxQ;t++){const o=Math.max(this.minR,-t-this.maxS),i=Math.min(this.maxR,-t+this.maxS);for(let r=o;r<=i;r++)e.push({q:t,r:r,s:-t-r})}return e}isWithinBoardBounds(e){if(!l(e))return!1;const{q:t,r:o,s:i}=e;return t>=this.minQ&&t<=this.maxQ&&o>=this.minR&&o<=this.maxR&&i>=this.minS&&i<=this.maxS}isValidPosition(e){return this.isWithinBoardBounds(e)}worldPosition(e){if(!l(e))throw new Error("Position must be a HexPosition");const t=e.q*this.HEX_WIDTH*.75,o=e.r*this.HEX_HEIGHT+e.q*this.HEX_HEIGHT/2;return{x:t-this.worldCenter.x,y:0,z:o-this.worldCenter.z}}getAdjacentPositions(e){if(!l(e))throw new Error("Position must be a HexPosition");return[{q:1,r:0,s:-1},{q:1,r:-1,s:0},{q:0,r:-1,s:1},{q:-1,r:0,s:1},{q:-1,r:1,s:0},{q:0,r:1,s:-1}].map((t=>({q:e.q+t.q,r:e.r+t.r,s:e.s+t.s}))).filter((e=>this.isWithinBoardBounds(e)))}}class S{constructor(){this.geometry=void 0,this.geometry=new q(5)}calculatePossibleMoves(e,t){const o=[],i=t.position;switch(t.type){case"pawn":const r="white"===t.color?{q:0,r:-1,s:1}:{q:0,r:1,s:-1},s=this.addHexPositions(i,r);if(this.isWithinBoardBounds(s)&&!this.getPieceAt(e,s)&&(o.push(s),!t.hasMoved)){const t=this.addHexPositions(s,r);this.isWithinBoardBounds(t)&&!this.getPieceAt(e,t)&&o.push(t)}("white"===t.color?[{q:1,r:-1,s:0},{q:-1,r:0,s:1}]:[{q:1,r:0,s:-1},{q:-1,r:1,s:0}]).forEach((r=>{const s=this.addHexPositions(i,r);if(this.isWithinBoardBounds(s)){const i=this.getPieceAt(e,s);i&&i.color!==t.color&&o.push(s)}}));break;case"rook":this.getHexDirections().forEach((t=>{for(let r=1;;r++){const s={q:i.q+t.q*r,r:i.r+t.r*r,s:i.s+t.s*r};if(!this.isWithinBoardBounds(s))break;if(o.push(s),this.getPieceAt(e,s))break}}));break;case"knight":[{q:3,r:-2,s:-1},{q:3,r:-1,s:-2},{q:1,r:-3,s:2},{q:2,r:-3,s:1},{q:2,r:1,s:-3},{q:1,r:2,s:-3},{q:-3,r:2,s:1},{q:-3,r:1,s:2},{q:-1,r:3,s:-2},{q:-2,r:3,s:-1},{q:-2,r:-1,s:3},{q:-1,r:-2,s:3}].forEach((e=>{const t={q:i.q+e.q,r:i.r+e.r,s:i.s+e.s};this.isWithinBoardBounds(t)&&o.push(t)}));break;case"bishop":[{q:1,r:-2,s:1},{q:2,r:-1,s:-1},{q:1,r:1,s:-2},{q:-1,r:2,s:-1},{q:-2,r:1,s:1},{q:-1,r:-1,s:2}].forEach((t=>{for(let r=1;;r++){const s={q:i.q+t.q*r,r:i.r+t.r*r,s:i.s+t.s*r};if(!this.isWithinBoardBounds(s))break;if(o.push(s),this.getPieceAt(e,s))break}}));break;case"queen":[...this.getHexDirections(),{q:1,r:-2,s:1},{q:2,r:-1,s:-1},{q:1,r:1,s:-2},{q:-1,r:2,s:-1},{q:-2,r:1,s:1},{q:-1,r:-1,s:2}].forEach((t=>{for(let r=1;;r++){const s={q:i.q+t.q*r,r:i.r+t.r*r,s:i.s+t.s*r};if(!this.isWithinBoardBounds(s))break;if(o.push(s),this.getPieceAt(e,s))break}}));break;case"king":[...this.getHexDirections(),{q:1,r:-2,s:1},{q:2,r:-1,s:-1},{q:1,r:1,s:-2},{q:-1,r:2,s:-1},{q:-2,r:1,s:1},{q:-1,r:-1,s:2}].forEach((e=>{const t=this.addHexPositions(i,e);this.isWithinBoardBounds(t)&&o.push(t)}))}return o.filter((o=>(!this.getPieceAt(e,o)||this.getPieceAt(e,o).color!==t.color)&&this.isWithinBoardBounds(o)))}getLegalMovesForPiece(e,t){return this.calculatePossibleMoves(e,t)}isPositionUnderAttack(e,t,o){return e.board.some((i=>i.color===o&&this.calculatePossibleMoves(e,i).some((e=>v(e,t)))))}makeMove(e,t){e.capturedPieces||(e.capturedPieces={white:[],black:[]});const o=e.board.map((e=>({...e}))),i=o.find((e=>v(e.position,t.from)&&e.type===t.piece.type&&e.color===t.piece.color));if(!i)return console.warn(`No ${t.piece.color} ${t.piece.type} found at position: ${g(t.from)}`),e;const r=this.getPieceAt({...e,board:o},t.to),s={...e,board:o.filter((e=>e.id!==i.id)),currentTurn:"white"===e.currentTurn?"black":"white",moveHistory:new f(e.moveHistory.initialState,e.moveHistory.moves).addMove(t),capturedPieces:{white:[...e.capturedPieces.white],black:[...e.capturedPieces.black]}};if(r&&(s.capturedPieces[r.color].push(r),s.board=s.board.filter((e=>e.id!==r.id))),"pawn"===i.type&&("white"===i.color&&-5===t.to.r||"black"===i.color&&5===t.to.r)){const e=t.promotionType||"queen";s.board.push({...i,position:t.to,hasMoved:!0,type:e})}else s.board.push({...i,position:t.to,hasMoved:!0});return s}getAttackersOfSquare(e,t,o){const i=d(t);return e.board.filter((t=>t.color===o&&this.calculatePossibleMoves(e,t).some((e=>v(e,i)))))}validateMove(e,t){const o=[],i=this.getPieceAt(e,t.from);if(!i)return o.push(`No piece found at position: ${JSON.stringify(t.from)}`),o;i.color!==e.currentTurn&&o.push(`It's not ${i.color}'s turn`),this.isWithinBoardBounds(t.to)||o.push("Destination position is outside the board bounds");return this.calculatePossibleMoves(e,i).some((e=>v(e,t.to)))||o.push("The move is not in the list of legal moves for this piece"),o}isLegalMove(e,t){return 0===this.validateMove(e,t).length}isWithinBoardBounds(e){var t,o,i,r,s,n;const{q:a,r:c,s:l}=p(e);if(!this.geometry)return!1;const h=null!==(t=this.geometry.minQ)&&void 0!==t?t:-5,u=null!==(o=this.geometry.maxQ)&&void 0!==o?o:5,d=null!==(i=this.geometry.minR)&&void 0!==i?i:-5,v=null!==(r=this.geometry.maxR)&&void 0!==r?r:5,g=null!==(s=this.geometry.minS)&&void 0!==s?s:-5,f=null!==(n=this.geometry.maxS)&&void 0!==n?n:5;return a>=h&&a<=u&&c>=d&&c<=v&&l>=g&&l<=f}isThreefoldRepetition(e){return!1}getWinner(e){const t=e.board.find((e=>"king"===e.type&&"white"===e.color)),o=e.board.find((e=>"king"===e.type&&"black"===e.color));return t?o?this.isInCheckmate(e,"white")?"black":this.isInCheckmate(e,"black")?"white":this.isStalemate(e)||this.isThreefoldRepetition(e)||this.isInsufficientMaterial(e)?"draw":null:"white":"black"}getInitialState(){const e=this.getInitialBoardState();return{board:e,currentTurn:"white",moveHistory:new f(e),capturedPieces:{white:[],black:[]},gameMode:"head-to-head",gameOver:!1,enPassantTarget:null}}isGameOver(e){return null!==this.getWinner(e)||this.isThreefoldRepetition(e)}isInCheck(e,t){const o=e.board.find((e=>"king"===e.type&&e.color===t));if(!o)return!1;const i="white"===t?"black":"white";return this.getAttackersOfSquare(e,o.position,i).length>0}isUnderAttack(e,t,o){return this.getAttackersOfSquare(e,t,o).length>0}isInCheckmate(e,t){return!!this.isInCheck(e,t)&&this.getPiecesByColor(e,t).every((t=>0===this.getLegalMovesForPiece(e,t).length))}isStalemate(e){return!this.isInCheck(e,e.currentTurn)&&this.getPiecesByColor(e,e.currentTurn).every((t=>0===this.getLegalMovesForPiece(e,t).length))}getPiecesByColor(e,t){return e.board.filter((e=>e.color===t))}getPieceAt(e,t){const o=d(t);return e.board.find((e=>v(e.position,o)))||null}isInsufficientMaterial(e){const t=e.board||[];if(t.length>4)return!1;if(t.every((e=>e&&"king"===e.type)))return!0;if(3===t.length)return t.some((e=>e&&("bishop"===e.type||"knight"===e.type)));if(4===t.length){if(2===t.filter((e=>e&&"bishop"===e.type)).length)return!0;if(2===t.filter((e=>e&&"knight"===e.type)).length)return!0}return!1}undoMove(e){const t=e.moveHistory.moves[e.moveHistory.moves.length-1];if(!t)return e;let o=new f(e.moveHistory.initialState,e.moveHistory.moves.slice(0,-1));o.undoneMoves=[t,...e.moveHistory.undoneMoves];const i={...e,board:[...e.board],currentTurn:"white"===e.currentTurn?"black":"white",moveHistory:o},r=this.getPieceAt(i,t.to);if(r&&(r.position=t.from,r.hasMoved=!t.isFirstMove),t.capturedPiece){i.board.push(t.capturedPiece);const e=t.capturedPiece.color;i.capturedPieces[e]=i.capturedPieces[e].filter((e=>e.id!==t.capturedPiece.id))}return i}redoMove(e){const t=e.moveHistory.undoneMoves[0];if(!t)return e;let o=new f(e.moveHistory.initialState,[...e.moveHistory.moves,t]);o.undoneMoves=e.moveHistory.undoneMoves.slice(1);const i={...e,board:[...e.board],currentTurn:"white"===e.currentTurn?"black":"white",moveHistory:o},r=this.getPieceAt(i,t.from);return r&&(r.position=t.to,r.hasMoved=!0),t.capturedPiece&&(i.board=i.board.filter((e=>e.id!==t.capturedPiece.id)),i.capturedPieces[t.capturedPiece.color].push(t.capturedPiece)),i}importState(e){const t=JSON.parse(e);if(!t.board||!Array.isArray(t.board))throw new Error("Invalid state: board is missing or not an array");if(!t.currentTurn||"white"!==t.currentTurn&&"black"!==t.currentTurn)throw new Error("Invalid state: currentTurn is missing or invalid");if(t.moveHistory?t.moveHistory instanceof f||(t.moveHistory=new f(t.board,t.moveHistory._moves||[])):t.moveHistory=new f([]),!t.capturedPieces||"object"!==typeof t.capturedPieces)throw new Error("Invalid state: capturedPieces is missing or not an object");return t}exportState(e){return JSON.stringify(e)}getHexDirections(){return[{q:1,r:-1,s:0},{q:1,r:0,s:-1},{q:0,r:-1,s:1},{q:0,r:1,s:-1},{q:-1,r:0,s:1},{q:-1,r:1,s:0}]}addHexPositions(e,t){return{q:e.q+t.q,r:e.r+t.r,s:e.s+t.s}}getInitialBoardState(){const e=[],t=(t,o,i,r,s)=>{e.push({type:t,color:o,position:{q:i,r:r,s:s},id:x(),hasMoved:!1})};let o=-2,i=5,r=-o-i;t("rook","white",r++,i,o--),t("knight","white",r++,i,o--),t("queen","white",r++,i,o--),t("bishop","white",r,i-1,o),t("bishop","white",r,i-2,o),t("bishop","white",r++,i--,o),t("king","white",r++,i--,o),t("knight","white",r++,i--,o),t("rook","white",r++,i--,o),o=-1,i=5,r=-o-i;for(let s=0;s<4;s++)t("pawn","white",r++,i--,o);for(let s=0;s<5;s++)t("pawn","white",r++,i,o--);o=2,i=-5,r=-o-i,t("rook","black",r--,i,o++),t("knight","black",r--,i,o++),t("queen","black",r--,i,o++),t("bishop","black",r,i+1,o),t("bishop","black",r,i+2,o),t("bishop","black",r--,i++,o),t("king","black",r--,i++,o),t("knight","black",r--,i++,o),t("rook","black",r--,i++,o),o=1,i=-5,r=-o-i;for(let s=0;s<4;s++)t("pawn","black",r--,i++,o);for(let s=0;s<5;s++)t("pawn","black",r--,i,o++);return e}}const H={depthLimit:2,timeLimit:3e3,randomnessFactor:.1,verbosityLevel:0};let B=null,T=null,W=0;const L=self;L.onmessage=async e=>{console.log("[AIWorker] Received message:",e.data);const{type:t,currentState:o,aiConfig:i=H,gameType:r}=e.data||{};if(!t)return console.error("Invalid message type received in worker",e.data),void L.postMessage({type:"error",error:"Invalid message type"});switch(t){case"init":console.log("[AIWorker] Initializing AI with config:",i,"gameType:",r),function(e,t){const o={...H,...e};console.log(`[AIWorker] Initializing AI for ${t} chess with config:`,o),console.log("[AIWorker] Initializing AI for",t,"chess with config:",o),B=new m,T="standard"===t?new y:new S,B.initialize(T,o),console.log("[AIWorker] AI initialized successfully"),L.postMessage({type:"status",message:"AI initialized"})}(i,r);break;case"calculate":if(!o){const e="Invalid game state received in worker";return console.error("[AIWorker]",e),void L.postMessage({type:"error",error:e})}console.log("[AIWorker] Calculating best move for state:",`Turn: ${o.currentTurn}, Pieces: ${o.board.length}`),async function(e){if(!B||!T)return console.error("[AIWorker] AI or game model not initialized"),void L.postMessage({type:"error",error:"AI not initialized"});W=performance.now(),L.postMessage({type:"status",message:"AI calculation started"});try{console.log("[AIWorker] AI calculation started at",(new Date).toISOString());const t=await B.calculateBestMove(e),o=performance.now()-W;!function(e,t){if(!e)return void console.warn("[AIWorker] No move returned after",t,"ms");console.log(`[AIWorker] Best move found after ${t.toFixed(2)}ms:`,`${JSON.stringify(e.from)} \u2192 ${JSON.stringify(e.to)}`),t>5e3&&console.warn("[AIWorker] Move calculation took longer than 5 seconds:",t,"ms")}(t,o),t?L.postMessage({type:"move",move:t,stats:{calculationTime:o,timestamp:(new Date).toISOString()}}):(console.warn("[AIWorker] No valid move found after",o,"ms"),L.postMessage({type:"error",error:"No valid move found"}))}catch(t){!function(e){const t=performance.now()-W;e instanceof Error?"AbortError"===e.name?(console.log(`[AIWorker] AI calculation aborted after ${t.toFixed(2)}ms`),L.postMessage({type:"status",message:"AI calculation aborted"})):(console.error(`[AIWorker] AI calculation error after ${t.toFixed(2)}ms:`,e),L.postMessage({type:"error",error:e.message})):(console.error(`[AIWorker] Unknown error occurred after ${t.toFixed(2)}ms:`,e),L.postMessage({type:"error",error:"An unknown error occurred"}))}(t)}}(o);break;case"abort":console.log("[AIWorker] Aborting calculation"),function(){if(B){B.abortCalculation();const e=performance.now()-W;console.log(`[AIWorker] AI calculation aborted after ${e.toFixed(2)}ms`),L.postMessage({type:"status",message:"AI calculation aborted"})}else console.warn("[AIWorker] Abort called but AI player is not initialized")}();break;default:console.error("[AIWorker] Unknown message type:",t),L.postMessage({type:"error",error:"Unknown message type"})}}})();